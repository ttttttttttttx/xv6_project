1.函数参数存储在寄存器 a0~a7 中
  main 函数对 printf 的调用中，13寄存在a2寄存器中

2.查看 call.asm 文件中的 f 和 g 函数可知
  函数 f 调用函数 g ,函数 g 使传入的参数 +3 后返回

  编译器会进行内联优化
  即一些编译时可以计算的数据会在编译时得出结果，而不是进行函数调用

  查看 main 函数可以发现, printf 中包含了一个对 f 的调用
  但是对应的会汇编代码却是直接将 f(8)+1 替换为 12 
  这就说明编译器对这个函数调用进行了优化
  所以对于 main 函数的汇编代码来说，并没有调用函数 f 和 g,
  而是在运行之前由编译器对其进行了计算

  没有这样的代码，g 被内联inline到 f(x) 中，然后 f 又被进一步内联到 main 中

3. printf 的入口地址为 0x628

4. jalr 指令执⾏完毕之后，ra 的值为 0x38 

5.程序得输出为：HE110 World
  如果在大端序，i 的值应该为 0x00726c64 
  才能保证与小端序输出的内容相同
  不需要改变 57616 的值

6.程序输出：x=3 y=5213
  输出的是一个受调用前的代码影响的随机值
  因为 printf 尝试读的参数数量比提供的参数数量多
  第二个参数 3 通过 a1 传递
  而第三个参数对应的寄存器 a2 在调用前不会被设置为任何具体的值
  而是会包含调用发生前的任何已经在里面的值